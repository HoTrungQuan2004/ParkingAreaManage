<!DOCTYPE html>
<html>
<head>
    <title>Smart Parking Management System</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="Style.css">

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <!-- Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1> Smart Parking Management System</h1>
            <div class="last-updated" id="lastUpdated">Last Updated: --</div>
            <button onclick="refreshData()" style="margin-top: 10px; padding: 8px 16px; background: #2196f3; color: white; border: none; border-radius: 5px; cursor: pointer;">üîÑ Refresh Data</button>
        </header>

        <!-- Parking Statistics Dashboard -->
        <div class="dashboard">
            <div class="stat-card total">
                <h3>Total Slots</h3>
                <div class="stat-number" id="totalSlots">--</div>
            </div>
            <div class="stat-card occupied">
                <h3>Occupied</h3>
                <div class="stat-number" id="occupiedSlots">--</div>
            </div>
            <div class="stat-card available">
                <h3>Available</h3>
                <div class="stat-number" id="availableSlots">--</div>
            </div>
            <div class="stat-card occupancy">
                <h3>Occupancy Rate</h3>
                <div class="stat-number" id="occupancyRate">--%</div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="charts-section">
            <div class="chart-container">
                <h3> Daily Vehicle Count (Last 7 Days)</h3>
                <canvas id="dailyChart"></canvas>
            </div>
            <div class="chart-container">
                <h3> Monthly Vehicle Count (Last 6 Months)</h3>
                <canvas id="monthlyChart"></canvas>
            </div>
        </div>

        <!-- Current Vehicles Section -->
        <div class="vehicles-section">
            <h2> Currently Parked Vehicles</h2>
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="üîç Search by license plate..." />
            </div>
            <div id="currentVehiclesList" class="vehicles-list"></div>
        </div>

        <!-- Recent Activity Section -->
        <div class="activity-section">
            <h2> Recent Activity</h2>
            <div class="activity-tabs">
                <button class="tab-button active" onclick="showTab('entries')">Recent Entries</button>
                <button class="tab-button" onclick="showTab('exits')">Recent Exits</button>
            </div>
            <div id="recentEntriesList" class="activity-list"></div>
            <div id="recentExitsList" class="activity-list" style="display: none;"></div>
        </div>
    </div>

    <script>
        // Configuration object for the parking system
        const PARKING_CONFIG = {
            TOTAL_SLOTS: 100,
            REFRESH_INTERVAL: 30000, // 30 seconds
            MAX_RECENT_ENTRIES: 50,
            MAX_DISPLAY_ENTRIES: 20,
            CHART_UPDATE_DELAY: 1000,
            FIREBASE_RETRY_DELAY: 2000,
            SAMPLE_DATA_DELAY: 3000
        };

        // Debug function to check Firebase configuration
        function debugFirebaseConfig() {
            console.log('=== Firebase Debug Information ===');
            console.log('Firebase Config:', {
                apiKey: firebaseConfig.apiKey ? '***' + firebaseConfig.apiKey.slice(-4) : 'MISSING',
                authDomain: firebaseConfig.authDomain,
                databaseURL: firebaseConfig.databaseURL,
                projectId: firebaseConfig.projectId
            });
            
            // Check if Firebase scripts loaded
            console.log('Firebase app available:', typeof firebase !== 'undefined');
            console.log('Firebase database available:', typeof firebase?.database === 'function');
            
            // Check network connectivity
            if (navigator.onLine) {
                console.log('Network: Online');
            } else {
                console.log('Network: Offline');
            }
        }

        // Replace with your actual Firebase project configuration
        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
        const firebaseConfig = {
            apiKey: "YourapiKey",
            authDomain: "yourauthDomain.firebaseapp.com",
            databaseURL: "your databaseURL",
            projectId: "Your projectId",
            storageBucket: "yourstrorageBucket.firebasestorage.app",
            messagingSenderId: "YourSenderId",
            appId: "YourappId",
            measurementId: "Your measurementId"
        };

        // Global variables
        let currentVehicles = {};
        let recentEntries = [];
        let recentExits = [];
        let dailyChart, monthlyChart;
        let db; // Firebase database reference

        // Initialize Firebase when DOM is ready
        function initializeFirebase() {
            try {
                updateConnectionStatus('connecting');
                debugFirebaseConfig();
                
                // Check if Firebase is loaded
                if (typeof firebase === 'undefined') {
                    throw new Error('Firebase SDK not loaded. Check your internet connection.');
                }
                
                firebase.initializeApp(firebaseConfig);
                db = firebase.database();
                console.log('Firebase initialized successfully');
                
                // Test database connection
                db.ref('.info/connected').on('value', function(snapshot) {
                    if (snapshot.val() === true) {
                        console.log('Connected to Firebase Realtime Database');
                        updateConnectionStatus('connected');
                        const lastUpdatedEl = document.querySelector('#lastUpdated');
                        if (lastUpdatedEl) {
                            const statusText = lastUpdatedEl.textContent.replace(/^.*?Last Updated:/, 'Last Updated:');
                            lastUpdatedEl.innerHTML = `<span class="connection-status connected"></span>${statusText || 'Connected - ' + new Date().toLocaleString()}`;
                        }
                    } else {
                        console.log('Disconnected from Firebase Realtime Database');
                        updateConnectionStatus('disconnected');
                        const lastUpdatedEl = document.querySelector('#lastUpdated');
                        if (lastUpdatedEl) {
                            lastUpdatedEl.innerHTML = `<span class="connection-status disconnected"></span>Connection Lost`;
                        }
                    }
                }, function(error) {
                    console.error('Connection monitoring error:', error);
                    updateConnectionStatus('disconnected');
                });
                
            } catch (error) {
                console.error('Firebase initialization error:', error);
                console.error('Error details:', {
                    message: error.message,
                    code: error.code,
                    stack: error.stack
                });
                
                updateConnectionStatus('disconnected');
                
                // More specific error messages
                let errorMessage = 'Failed to connect to Firebase. ';
                if (error.message.includes('not loaded')) {
                    errorMessage += 'Firebase SDK failed to load. Check your internet connection.';
                } else if (error.code === 'app/invalid-api-key') {
                    errorMessage += 'Invalid API key in configuration.';
                } else if (error.code === 'app/invalid-app-argument') {
                    errorMessage += 'Invalid Firebase configuration.';
                } else {
                    errorMessage += 'Please check your configuration and internet connection.';
                }
                
                alert(errorMessage);
                
                // Update UI to show error
                const lastUpdatedEl = document.querySelector('#lastUpdated');
                if (lastUpdatedEl) {
                    lastUpdatedEl.innerHTML = `<span class="connection-status disconnected"></span>Firebase connection failed`;
                }
            }
        }

        // DOM elements - Initialize after DOM is ready
        let totalSlotsEl, occupiedSlotsEl, availableSlotsEl, occupancyRateEl;
        let lastUpdatedEl, currentVehiclesListEl, recentEntriesListEl, recentExitsListEl, searchInputEl;

        // Initialize DOM elements
        function initializeDOMElements() {
            totalSlotsEl = document.getElementById('totalSlots');
            occupiedSlotsEl = document.getElementById('occupiedSlots');
            availableSlotsEl = document.getElementById('availableSlots');
            occupancyRateEl = document.getElementById('occupancyRate');
            lastUpdatedEl = document.getElementById('lastUpdated');
            currentVehiclesListEl = document.getElementById('currentVehiclesList');
            recentEntriesListEl = document.getElementById('recentEntriesList');
            recentExitsListEl = document.getElementById('recentExitsList');
            searchInputEl = document.getElementById('searchInput');
            
            console.log('DOM elements initialized:', {
                totalSlots: !!totalSlotsEl,
                occupiedSlots: !!occupiedSlotsEl,
                availableSlots: !!availableSlotsEl,
                occupancyRate: !!occupancyRateEl,
                lastUpdated: !!lastUpdatedEl,
                currentVehiclesList: !!currentVehiclesListEl,
                recentEntriesList: !!recentEntriesListEl,
                recentExitsList: !!recentExitsListEl,
                searchInput: !!searchInputEl
            });
        }

        // Initialize charts
        function initCharts() {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                }
            };

            dailyChart = new Chart(document.getElementById('dailyChart'), {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: '#2196f3',
                        borderColor: '#1976d2',
                        borderWidth: 1
                    }]
                },
                options: chartOptions
            });

            monthlyChart = new Chart(document.getElementById('monthlyChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: 'rgba(33, 150, 243, 0.1)',
                        borderColor: '#2196f3',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: chartOptions
            });
        }

        // Update parking statistics
        function updateParkingStats(stats) {
            if (stats && totalSlotsEl && occupiedSlotsEl && availableSlotsEl && occupancyRateEl) {
                totalSlotsEl.textContent = stats.total_slots || 0;
                occupiedSlotsEl.textContent = stats.occupied_slots || 0;
                availableSlotsEl.textContent = stats.available_slots || 0;
                
                const occupancyPercentage = stats.total_slots > 0 
                    ? Math.round((stats.occupied_slots / stats.total_slots) * 100) 
                    : 0;
                occupancyRateEl.textContent = occupancyPercentage + '%';
                
                // Update occupancy rate color based on percentage
                const occupancyCard = document.querySelector('.stat-card.occupancy');
                if (occupancyCard) {
                    occupancyCard.className = 'stat-card occupancy';
                    if (occupancyPercentage >= 90) {
                        occupancyCard.classList.add('critical');
                    } else if (occupancyPercentage >= 70) {
                        occupancyCard.classList.add('warning');
                    }
                }
                
                if (stats.last_updated && lastUpdatedEl) {
                    lastUpdatedEl.textContent = `Last Updated: ${formatDateTime(stats.last_updated)}`;
                    lastUpdatedEl.style.color = '#4caf50';
                }
                
                console.log('Parking stats updated:', stats);
            } else {
                console.warn('Cannot update parking stats - DOM elements or stats data missing');
            }
        }

        // Format date and time
        function formatDateTime(dateTimeString) {
            const date = new Date(dateTimeString);
            return date.toLocaleString();
        }

        // Format date only
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString();
        }

        // Add current vehicle to list
        function addCurrentVehicle(key, data) {
            currentVehicles[key] = data;
            displayCurrentVehicles();
        }

        // Remove current vehicle from list
        function removeCurrentVehicle(key) {
            if (currentVehicles[key]) {
                // Add to recent exits
                const exitData = {
                    ...currentVehicles[key],
                    exit_time: new Date().toISOString().replace('T', ' ').substr(0, 19)
                };
                recentExits.unshift(exitData);
                if (recentExits.length > 50) recentExits.pop();
                
                delete currentVehicles[key];
                displayCurrentVehicles();
                displayRecentExits();
            }
        }

        // Display current vehicles
        function displayCurrentVehicles() {
            if (!currentVehiclesListEl) {
                console.log('DOM elements not ready for displayCurrentVehicles');
                return;
            }

            const searchTerm = searchInputEl && searchInputEl.value ? searchInputEl.value.toLowerCase() : '';
            const vehicleEntries = Object.entries(currentVehicles);
            
            let filteredVehicles = vehicleEntries;
            if (searchTerm) {
                filteredVehicles = vehicleEntries.filter(([key, data]) =>
                    (data.number_plate && data.number_plate.toLowerCase().includes(searchTerm)) ||
                    (key && key.toLowerCase().includes(searchTerm))
                );
            }

            currentVehiclesListEl.innerHTML = '';
            
            if (filteredVehicles.length === 0) {
                const emptyMessage = searchTerm ? 'No vehicles found matching your search' : 'No vehicles currently parked (waiting for ESP32 data...)';
                currentVehiclesListEl.innerHTML = `<div class="empty-state">${emptyMessage}</div>`;
                return;
            }

            console.log('Displaying vehicles:', filteredVehicles.length);

            filteredVehicles.forEach(([key, data]) => {
                const vehicleEl = document.createElement('div');
                vehicleEl.className = 'plate current-vehicle';
                
                // Handle different timestamp formats
                let entryTime;
                try {
                    if (data.entry_time) {
                        entryTime = new Date(data.entry_time);
                    } else if (data.date_time) {
                        // Handle ESP32 format "2025-05-23 22:54:54"
                        entryTime = new Date(data.date_time.replace(' ', 'T') + 'Z');
                        if (isNaN(entryTime.getTime())) {
                            entryTime = new Date(data.date_time);
                        }
                    } else if (data.timestamp) {
                        entryTime = new Date(data.timestamp);
                    } else if (data.detected_time) {
                        entryTime = new Date(data.detected_time);
                    }
                    
                    // Validate the parsed date
                    if (!entryTime || isNaN(entryTime.getTime())) {
                        throw new Error('Invalid date');
                    }
                } catch (error) {
                    console.error('Error parsing entry time for vehicle', key, error, {
                        entry_time: data.entry_time,
                        date_time: data.date_time,
                        timestamp: data.timestamp,
                        detected_time: data.detected_time
                    });
                    // Skip this vehicle if no valid timestamp
                    return;
                }
                
                const now = new Date();
                const duration = Math.max(0, Math.floor((now - entryTime) / (1000 * 60))); // minutes
                
                let durationText = '';
                if (duration < 1) {
                    durationText = 'Just arrived';
                } else if (duration < 60) {
                    durationText = `${duration} min`;
                } else if (duration < 1440) {
                    const hours = Math.floor(duration / 60);
                    const mins = duration % 60;
                    durationText = mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                } else {
                    const days = Math.floor(duration / 1440);
                    const hours = Math.floor((duration % 1440) / 60);
                    durationText = hours > 0 ? `${days}d ${hours}h` : `${days}d`;
                }
                
                const plateNumber = data.number_plate || key;
                const formattedEntryTime = entryTime.toLocaleString();
                
                vehicleEl.innerHTML = `
                    <div class="vehicle-info">
                        <div class="plate-number"> ${plateNumber}</div>
                        <div class="vehicle-details">
                            <span class="entry-time"> Entered: ${formattedEntryTime}</span>
                            <span class="duration">‚è±Duration: ${durationText}</span>
                        </div>
                    </div>
                    ${data.image ? `<div class="vehicle-image"><img src="data:image/jpeg;base64,${data.image}" alt="Vehicle Image" onclick="showImageModal(this.src)" style="max-width: 100px; max-height: 100px; cursor: pointer; border-radius: 5px;"></div>` : ''}
                `;
                
                currentVehiclesListEl.appendChild(vehicleEl);
            });
        }

        // Display recent entries
        function displayRecentEntries() {
            if (!recentEntriesListEl) {
                console.log('recentEntriesListEl not ready');
                return;
            }

            recentEntriesListEl.innerHTML = '';
            
            if (recentEntries.length === 0) {
                recentEntriesListEl.innerHTML = '<div class="empty-state">No recent entries (waiting for ESP32 data...)</div>';
                return;
            }

            // Sort entries by time (newest first)
            const sortedEntries = [...recentEntries].sort((a, b) => {
                const timeA = new Date(a.entry_time || a.timestamp || a.detected_time || 0);
                const timeB = new Date(b.entry_time || b.timestamp || b.detected_time || 0);
                return timeB - timeA;
            });

            sortedEntries.slice(0, 20).forEach(data => {
                if (data && (data.number_plate || data.key)) {
                    const entryEl = document.createElement('div');
                    entryEl.className = 'plate activity-entry';
                    
                    const plateNumber = data.number_plate || data.key || 'Unknown';
                    
                    // Handle different timestamp formats
                    let entryTime;
                    try {
                        if (data.entry_time) {
                            entryTime = new Date(data.entry_time);
                        } else if (data.date_time) {
                            // Handle ESP32 format "2025-05-23 22:54:54"
                            entryTime = new Date(data.date_time.replace(' ', 'T') + 'Z');
                            if (isNaN(entryTime.getTime())) {
                                entryTime = new Date(data.date_time);
                            }
                        } else if (data.timestamp) {
                            entryTime = new Date(data.timestamp);
                        } else if (data.detected_time) {
                            entryTime = new Date(data.detected_time);
                        }
                        
                        // Validate the parsed date
                        if (!entryTime || isNaN(entryTime.getTime())) {
                            throw new Error('Invalid date');
                        }
                    } catch (error) {
                        console.error('Error parsing entry time for recent entry:', error, data);
                        return; // Skip this entry if no valid timestamp
                    }
                    
                    entryEl.innerHTML = `
                        <div class="activity-info">
                            <div class="plate-number"> ${plateNumber}</div>
                            <div class="activity-time"> ${entryTime.toLocaleString()}</div>
                            <div class="activity-status">Status: Vehicle Entered</div>
                        </div>
                    `;
                    recentEntriesListEl.appendChild(entryEl);
                }
            });
        }

        // Display recent exits
        function displayRecentExits() {
            if (!recentExitsListEl) {
                console.log('recentExitsListEl not ready');
                return;
            }

            recentExitsListEl.innerHTML = '';
            
            if (recentExits.length === 0) {
                recentExitsListEl.innerHTML = '<div class="empty-state">No recent exits (waiting for ESP32 data...)</div>';
                return;
            }

            recentExits.slice(0, 20).forEach(data => {
                if (data && data.number_plate && data.exit_time) {
                    const exitEl = document.createElement('div');
                    exitEl.className = 'plate activity-exit';
                    exitEl.innerHTML = `
                        <div class="activity-info">
                            <div class="plate-number"> ${data.number_plate}</div>
                            <div class="activity-time"> ${formatDateTime(data.exit_time)}</div>
                            <div class="activity-status">Status: Vehicle Exited</div>
                        </div>
                    `;
                    recentExitsListEl.appendChild(exitEl);
                }
            });
        }

        // Update daily chart
        function updateDailyChart(dailyData) {
            const last7Days = [];
            const counts = [];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                last7Days.push(date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }));
                
                // Check if data exists for this date
                const dayData = dailyData && dailyData[dateStr] ? dailyData[dateStr].count : 0;
                counts.push(dayData);
            }
            
            console.log('Updating daily chart with:', { labels: last7Days, data: counts });
            
            if (dailyChart) {
                dailyChart.data.labels = last7Days;
                dailyChart.data.datasets[0].data = counts;
                dailyChart.update();
            }
        }

        // Update monthly chart
        function updateMonthlyChart(monthlyData) {
            const last6Months = [];
            const counts = [];
            
            for (let i = 5; i >= 0; i--) {
                const date = new Date();
                date.setMonth(date.getMonth() - i);
                const monthStr = date.toISOString().substr(0, 7);
                last6Months.push(date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }));
                
                // Check if data exists for this month
                const monthData = monthlyData && monthlyData[monthStr] ? monthlyData[monthStr].count : 0;
                counts.push(monthData);
            }
            
            console.log('Updating monthly chart with:', { labels: last6Months, data: counts });
            
            if (monthlyChart) {
                monthlyChart.data.labels = last6Months;
                monthlyChart.data.datasets[0].data = counts;
                monthlyChart.update();
            }
        }

        // Update parking statistics from Firebase parking_stats
        function updateParkingStatsFromFirebase() {
            if (!db) {
                console.error('Database not initialized');
                return;
            }

            db.ref('parking_stats').once('value').then(snapshot => {
                const statsData = snapshot.val();
                
                if (statsData) {
                    console.log('Firebase parking stats:', statsData);
                    
                    updateParkingStats({
                        total_slots: statsData.total_slots || PARKING_CONFIG.TOTAL_SLOTS,
                        occupied_slots: statsData.occupied_slots || 0,
                        available_slots: statsData.available_slots || PARKING_CONFIG.TOTAL_SLOTS,
                        last_updated: statsData.last_updated || new Date().toISOString()
                    });
                } else {
                    // Fallback to counting vehicles if no parking_stats
                    updateParkingStatsFromVehicles();
                }
            }).catch(error => {
                console.error('Error reading parking_stats:', error);
                // Fallback to counting vehicles
                updateParkingStatsFromVehicles();
            });
        }

        // Fallback: Update parking statistics based on vehicles count
        function updateParkingStatsFromVehicles() {
            if (!db) {
                console.error('Database not initialized');
                return;
            }

            db.ref('vehicles').once('value').then(snapshot => {
                const vehiclesData = snapshot.val();
                let occupiedCount = 0;
                
                if (vehiclesData) {
                    // Count all vehicles entries as currently parked vehicles
                    occupiedCount = Object.keys(vehiclesData).length;
                }
                
                const totalSlots = PARKING_CONFIG.TOTAL_SLOTS;
                const availableSlots = Math.max(0, totalSlots - occupiedCount);
                
                console.log('Updating parking stats from vehicles count:', {
                    total: totalSlots,
                    occupied: occupiedCount,
                    available: availableSlots
                });

                updateParkingStats({
                    total_slots: totalSlots,
                    occupied_slots: occupiedCount,
                    available_slots: availableSlots,
                    last_updated: new Date().toISOString()
                });
            }).catch(error => {
                console.error('Error updating parking stats from vehicles:', error);
                // Show default values on error
                updateParkingStats({
                    total_slots: PARKING_CONFIG.TOTAL_SLOTS,
                    occupied_slots: 0,
                    available_slots: PARKING_CONFIG.TOTAL_SLOTS,
                    last_updated: new Date().toISOString()
                });
            });
        }

        // Update charts based on Firebase data
        function updateChartsFromFirebase() {
            updateDailyChartFromFirebase();
            updateMonthlyChartFromFirebase();
        }

        // Update daily chart from daily_counts and monthly chart from monthly_counts
        function updateDailyChartFromFirebase() {
            if (!db) {
                console.error('Database not initialized');
                return;
            }

            db.ref('daily_counts').once('value').then(snapshot => {
                const dailyCountsData = snapshot.val();
                
                console.log('Firebase daily_counts data:', dailyCountsData);
                
                if (dailyCountsData) {
                    // Convert Firebase daily_counts data to chart format
                    const chartData = {};
                    Object.keys(dailyCountsData).forEach(dateKey => {
                        // dateKey is in format "2025-05-23"
                        const dayData = dailyCountsData[dateKey];
                        chartData[dateKey] = { 
                            count: dayData.count || 0,
                            date: dayData.date || dateKey
                        };
                    });
                    updateDailyChart(chartData);
                } else {
                    console.log('No daily_counts data found - waiting for ESP32 data');
                    updateDailyChart({});
                }
            }).catch(error => {
                console.error('Error updating daily chart from daily_counts:', error);
                updateDailyChart({});
            });
        }

        // Update monthly chart from monthly_counts
        function updateMonthlyChartFromFirebase() {
            if (!db) {
                console.error('Database not initialized');
                return;
            }

            db.ref('monthly_counts').once('value').then(snapshot => {
                const monthlyCountsData = snapshot.val();
                
                console.log('Firebase monthly_counts data:', monthlyCountsData);
                
                if (monthlyCountsData) {
                    // Use Firebase monthly_counts data directly
                    const chartData = {};
                    Object.keys(monthlyCountsData).forEach(monthKey => {
                        // monthKey is in format "2025-05"
                        const monthData = monthlyCountsData[monthKey];
                        chartData[monthKey] = { 
                            count: monthData.count || 0,
                            month: monthData.month || monthData.Month || monthKey
                        };
                    });
                    updateMonthlyChart(chartData);
                } else {
                    console.log('No monthly_counts data found - waiting for ESP32 data, falling back to daily_counts aggregation');
                    updateMonthlyChartFromDailyCounts();
                }
            }).catch(error => {
                console.error('Error updating monthly chart from monthly_counts:', error);
                updateMonthlyChart({});
            });
        }

        // Update monthly chart based on daily_counts data
        function updateMonthlyChartFromDailyCounts() {
            if (!db) {
                console.error('Database not initialized');
                return;
            }

            db.ref('daily_counts').once('value').then(snapshot => {
                const dailyCountsData = snapshot.val();
                const monthlyCounts = {};

                if (dailyCountsData) {
                    // Aggregate daily counts into monthly counts
                    Object.keys(dailyCountsData).forEach(dateKey => {
                        try {
                            // dateKey is in format "2025-05-23"
                            const date = new Date(dateKey);
                            if (isNaN(date.getTime())) {
                                console.warn('Invalid date in daily_counts:', dateKey);
                                return;
                            }
                            
                            const monthKey = dateKey.substring(0, 7); // "2025-05" format
                            const count = dailyCountsData[dateKey].count || 1;
                            
                            if (!monthlyCounts[monthKey]) {
                                monthlyCounts[monthKey] = { count: 0 };
                            }
                            monthlyCounts[monthKey].count += count;
                        } catch (error) {
                            console.error('Error processing daily count for monthly chart:', dateKey, error);
                        }
                    });
                }

                console.log('Monthly counts for chart:', monthlyCounts);
                updateMonthlyChart(monthlyCounts);
            }).catch(error => {
                console.error('Error updating monthly chart from daily_counts:', error);
                updateMonthlyChart({});
            });
        }

        // Load initial data from Firebase vehicles structure (ESP32 data)
        function loadInitialDataFromVehicles() {
            if (!db) return;
            
            console.log('Loading real-time vehicle data from ESP32 via Firebase...');
            
            db.ref('vehicles').once('value').then(snapshot => {
                const vehiclesData = snapshot.val();
                console.log('Initial vehicles data loaded:', vehiclesData);
                
                if (vehiclesData) {
                    // Clear existing data
                    currentVehicles = {};
                    recentEntries = [];
                    
                    // Process each vehicle entry
                    Object.entries(vehiclesData).forEach(([recordId, vehicleData]) => {
                        const plateNumber = vehicleData.number_plate;
                        const timestamp = vehicleData.entry_time;
                        
                        if (!plateNumber || !timestamp) {
                            console.warn('Skipping vehicle record with missing data:', recordId, vehicleData);
                            return;
                        }
                        
                        // Parse timestamp
                        let entryTime;
                        try {
                            // Handle "2025-05-23 22:54:54" format or ISO format
                            if (timestamp.includes(' ') && !timestamp.includes('T')) {
                                entryTime = new Date(timestamp.replace(' ', 'T') + 'Z');
                            } else {
                                entryTime = new Date(timestamp);
                            }
                            
                            if (isNaN(entryTime.getTime())) {
                                throw new Error('Invalid date format');
                            }
                        } catch (error) {
                            console.error('Error parsing entry_time for vehicle record:', recordId, timestamp, error);
                            return;
                        }
                        
                        const entryData = {
                            recordId: recordId,
                            number_plate: plateNumber,
                            entry_time: entryTime.toISOString(),
                            date_time: timestamp,
                            timestamp: entryTime.toISOString(),
                            detected_time: entryTime.toISOString(),
                            image: vehicleData.image || null
                        };
                        
                        // Add to current vehicles (all vehicle entries are currently parked)
                        currentVehicles[recordId] = entryData;
                        
                        // Add to recent entries
                        recentEntries.push(entryData);
                    });
                    
                    // Sort recent entries by time (newest first)
                    recentEntries.sort((a, b) => new Date(b.entry_time) - new Date(a.entry_time));
                    
                    // Update all displays
                    displayCurrentVehicles();
                    displayRecentEntries();
                    updateParkingStatsFromFirebase();
                    updateChartsFromFirebase();
                    
                    console.log('Initial vehicles data loaded successfully. Current vehicles:', Object.keys(currentVehicles).length);
                } else {
                    console.log('No vehicle data found in Firebase - waiting for ESP32 to send data');
                    // Initialize empty displays with waiting message
                    displayCurrentVehicles();
                    displayRecentEntries();
                    updateParkingStatsFromFirebase();
                    updateChartsFromFirebase();
                }
            }).catch(error => {
                console.error('Error loading initial vehicles data:', error);
            });
        }

        // Legacy functions removed - now using vehicles, daily_counts, monthly_counts, and parking_stats structure

        // Setup Firebase listeners for real-time updates from ESP32
        function setupFirebaseListeners() {
            if (!db) {
                console.error('Database not initialized for listeners');
                return;
            }
            
            console.log('Setting up real-time Firebase listeners for ESP32 data...');
            
            try {
                // Listen for new vehicle entries
                db.ref('vehicles').on('child_added', snapshot => {
                    console.log('New vehicle detected:', snapshot.key, snapshot.val());
                    
                    const recordId = snapshot.key;
                    const data = snapshot.val();
                    
                    console.log('Raw vehicle data:', {
                        recordId: recordId,
                        data: data
                    });
                    
                    // Handle vehicle data structure - each entry represents a parked vehicle
                    const plateNumber = data.number_plate;
                    const timestamp = data.entry_time;
                    
                    if (!plateNumber || !timestamp) {
                        console.warn('Missing required data in vehicles - plate:', plateNumber, 'timestamp:', timestamp);
                        return;
                    }
                    
                    // Parse timestamp properly
                    let entryTime;
                    try {
                        // Handle ESP32 format: "2025-05-23 22:54:54"
                        if (timestamp.includes(' ') && !timestamp.includes('T')) {
                            entryTime = new Date(timestamp.replace(' ', 'T') + 'Z');
                        } else {
                            entryTime = new Date(timestamp);
                        }
                        
                        // Validate the parsed date
                        if (isNaN(entryTime.getTime())) {
                            console.error('Invalid timestamp format:', timestamp);
                            return;
                        }
                    } catch (error) {
                        console.error('Error parsing timestamp:', timestamp, error);
                        return;
                    }
                    
                    const entryData = {
                        recordId: recordId,
                        number_plate: plateNumber,
                        entry_time: entryTime.toISOString(),
                        date_time: timestamp,
                        timestamp: entryTime.toISOString(),
                        detected_time: entryTime.toISOString(),
                        image: data.image || null
                    };
                    
                    console.log('Processed vehicle entry data:', entryData);
                    
                    // Add to current vehicles (new vehicle entry = vehicle entered)
                    currentVehicles[recordId] = entryData;
                    
                    // Add to recent entries (limit to last 20)
                    recentEntries.unshift(entryData);
                    if (recentEntries.length > 20) {
                        recentEntries = recentEntries.slice(0, 20);
                    }
                    
                    // Update displays
                    displayCurrentVehicles();
                    displayRecentEntries();
                    updateParkingStatsFromFirebase();
                    
                    console.log('Vehicle entered:', plateNumber);
                }, error => {
                    console.error('Error reading vehicle entries:', error);
                });
                
                // Listen for vehicle data changes
                db.ref('vehicles').on('child_changed', snapshot => {
                    console.log('Vehicle data updated:', snapshot.key, snapshot.val());
                    
                    const recordId = snapshot.key;
                    const data = snapshot.val();
                    const plateNumber = data.number_plate;
                    
                    if (!plateNumber) return;
                    
                    // Parse timestamp
                    let entryTime;
                    try {
                        const timestamp = data.entry_time;
                        if (timestamp.includes(' ') && !timestamp.includes('T')) {
                            entryTime = new Date(timestamp.replace(' ', 'T') + 'Z');
                        } else {
                            entryTime = new Date(timestamp);
                        }
                        
                        if (isNaN(entryTime.getTime())) {
                            console.error('Invalid timestamp format in change:', timestamp);
                            return;
                        }
                    } catch (error) {
                        console.error('Error parsing timestamp in change:', error);
                        return;
                    }
                    
                    const entryData = {
                        recordId: recordId,
                        number_plate: plateNumber,
                        entry_time: entryTime.toISOString(),
                        date_time: data.entry_time,
                        timestamp: entryTime.toISOString(),
                        detected_time: entryTime.toISOString(),
                        image: data.image || null
                    };
                    
                    // Update current vehicles if it exists
                    if (currentVehicles[recordId]) {
                        currentVehicles[recordId] = entryData;
                    }
                    
                    // Update displays
                    displayCurrentVehicles();
                    displayRecentEntries();
                    updateParkingStatsFromFirebase();
                    
                }, error => {
                    console.error('Error on vehicle data change:', error);
                });
                
                // Listen for vehicle removals (vehicle exits)
                db.ref('vehicles').on('child_removed', snapshot => {
                    console.log('Vehicle removed (vehicle exited):', snapshot.key);
                    const recordId = snapshot.key;
                    const vehicleData = currentVehicles[recordId];
                    
                    if (vehicleData) {
                        // Add to recent exits
                        const exitData = {
                            ...vehicleData,
                            exit_time: new Date().toISOString()
                        };
                        recentExits.unshift(exitData);
                        if (recentExits.length > 20) {
                            recentExits = recentExits.slice(0, 20);
                        }
                        
                        // Remove from current vehicles
                        delete currentVehicles[recordId];
                        
                        // Update displays
                        displayCurrentVehicles();
                        displayRecentExits();
                    }
                    
                    updateParkingStatsFromFirebase();
                }, error => {
                    console.error('Error on vehicle removal:', error);
                });
                
                // Listen for parking_stats updates
                db.ref('parking_stats').on('value', snapshot => {
                    console.log('Parking stats updated:', snapshot.val());
                    updateParkingStatsFromFirebase();
                }, error => {
                    console.error('Error reading parking_stats:', error);
                });
                
                // Listen for daily_counts updates
                db.ref('daily_counts').on('value', snapshot => {
                    console.log('Daily counts updated:', snapshot.val());
                    updateDailyChartFromFirebase();
                }, error => {
                    console.error('Error reading daily_counts:', error);
                });
                
                // Listen for monthly_counts updates
                db.ref('monthly_counts').on('value', snapshot => {
                    console.log('Monthly counts updated:', snapshot.val());
                    updateMonthlyChartFromFirebase();
                }, error => {
                    console.error('Error reading monthly_counts:', error);
                });
                
                console.log('Firebase listeners set up successfully for all data structures');
                
                // Load initial data
                loadInitialDataFromVehicles();
                
            } catch (error) {
                console.error('Error setting up Firebase listeners:', error);
            }
        }

        // Test Firebase connection
        function testFirebaseConnection() {
            if (!db) {
                console.error('Database not initialized for testing');
                return;
            }

            console.log('Testing Firebase connection...');
            
            // Test read access to a simple path
            db.ref('.info/serverTimeOffset').once('value')
                .then(snapshot => {
                    console.log('Firebase read test successful, server time offset:', snapshot.val());
                    console.log('Testing database rules...');
                    
                    // Try to read the root to test permissions
                    return db.ref('/').limitToFirst(1).once('value');
                })
                .then(snapshot => {
                    console.log('Database rules test successful');
                    
                    // Update UI to show connection is working
                    const lastUpdatedEl = document.getElementById('lastUpdated');
                    if (lastUpdatedEl) {
                        lastUpdatedEl.textContent = 'Connected to Firebase - ' + new Date().toLocaleString();
                        lastUpdatedEl.style.color = '#4caf50';
                    }
                })
                .catch(error => {
                    console.error('Firebase connection test failed:', error);
                    
                    let errorMsg = 'Firebase connection failed: ';
                    if (error.code === 'PERMISSION_DENIED') {
                        errorMsg += 'Database rules deny access. Please check your Firebase security rules.';
                        console.error('SOLUTION: Go to Firebase Console > Realtime Database > Rules and set:');
                        console.error('{"rules": {".read": true, ".write": true}}');
                    } else if (error.code === 'NETWORK_ERROR') {
                        errorMsg += 'Network error. Check your internet connection.';
                    } else {
                        errorMsg += error.message;
                    }
                    
                    const lastUpdatedEl = document.getElementById('lastUpdated');
                    if (lastUpdatedEl) {
                        lastUpdatedEl.textContent = errorMsg;
                        lastUpdatedEl.style.color = '#f44336';
                    }
                });
        }

        // Initialize Firebase connection and load real-time data only
        function initializeRealTimeData() {
            if (!db) return;

            console.log('Loading real-time data from Firebase...');
            
            // Load initial data from all Firebase folders
            loadInitialDataFromVehicles();
            updateParkingStatsFromFirebase();
            updateChartsFromFirebase();
        }

        // Manual refresh function to reload real-time data from Firebase
        function refreshData() {
            console.log('Manually refreshing real-time data from Firebase...');
            
            if (!db) {
                console.error('Database not initialized for refresh');
                alert('Database not connected. Please check your Firebase configuration.');
                return;
            }
            
            // Show loading state
            const refreshButton = event.target;
            const originalText = refreshButton.innerHTML;
            refreshButton.innerHTML = 'üîÑ Refreshing...';
            refreshButton.disabled = true;
            
            // Refresh all real-time data from Firebase (ESP32 data)
            loadInitialDataFromVehicles();
            updateChartsFromFirebase();
            updateParkingStatsFromFirebase();
            
            // Reset button after 2 seconds
            setTimeout(() => {
                refreshButton.innerHTML = originalText;
                refreshButton.disabled = false;
                
                // Update last updated time
                const lastUpdatedEl = document.getElementById('lastUpdated');
                if (lastUpdatedEl && !lastUpdatedEl.textContent.includes('Failed')) {
                    lastUpdatedEl.textContent = `Last Updated: ${new Date().toLocaleString()}`;
                }
                
                console.log('Real-time data refresh completed');
            }, 2000);
        }

        // Add connection status indicator
        function updateConnectionStatus(status) {
            const lastUpdatedEl = document.getElementById('lastUpdated');
            if (!lastUpdatedEl) return;
            
            const statusIndicator = lastUpdatedEl.querySelector('.connection-status') || 
                document.createElement('span');
            statusIndicator.className = `connection-status ${status}`;
            
            if (!lastUpdatedEl.querySelector('.connection-status')) {
                lastUpdatedEl.insertBefore(statusIndicator, lastUpdatedEl.firstChild);
            }
            
            switch(status) {
                case 'connected':
                    lastUpdatedEl.style.color = '#4caf50';
                    break;
                case 'disconnected':
                    lastUpdatedEl.style.color = '#f44336';
                    break;
                case 'connecting':
                    lastUpdatedEl.style.color = '#ff9800';
                    break;
            }
        }

        // Show tab function for activity tabs
        function showTab(tab) {
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('recentEntriesList').style.display = 'none';
            document.getElementById('recentExitsList').style.display = 'none';
            
            if (tab === 'entries') {
                document.getElementById('recentEntriesList').style.display = 'block';
                buttons[0].classList.add('active');
            } else if (tab === 'exits') {
                document.getElementById('recentExitsList').style.display = 'block';
                buttons[1].classList.add('active');
            }
        }

        // Show image modal function
        function showImageModal(src) {
            const modal = document.createElement('div');
            modal.className = 'image-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                    <img src="${src}" alt="Vehicle Image">
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Initialize the application
        function init() {
            console.log('Initializing Smart Parking Management System...');
            
            // Initialize Firebase first
            initializeFirebase();
            
            // Initialize charts
            initCharts();
            
            // Setup search functionality after DOM is ready
            if (searchInputEl) {
                searchInputEl.addEventListener('input', displayCurrentVehicles);
                console.log('Search functionality initialized');
            } else {
                console.warn('Search input element not found');
            }
            
            // Test Firebase connection and setup listeners after initialization
            setTimeout(() => {
                testFirebaseConnection();
                setupFirebaseListeners();
            }, 1500);
            
            // Load real-time data from ESP32 via Firebase
            setTimeout(() => {
                initializeRealTimeData();
            }, 2000);
            
            // Auto-refresh data every 30 seconds
            setInterval(() => {
                if (db) {
                    updateParkingStatsFromFirebase();
                    updateChartsFromFirebase();
                }
            }, 30000);
            
            // Update timestamp display every minute
            setInterval(() => {
                const now = new Date();
                const lastUpdatedEl = document.getElementById('lastUpdated');
                if (lastUpdatedEl && !lastUpdatedEl.textContent.includes('Failed') && !lastUpdatedEl.textContent.includes('connection failed')) {
                    if (!lastUpdatedEl.textContent.includes('Connected to Firebase')) {
                        lastUpdatedEl.textContent = `Last Updated: ${now.toLocaleString()}`;
                    }
                }
            }, 60000);
            
            console.log('Application initialization completed');
        }

        // Start the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded, starting application...');
            
            // Initialize DOM elements first
            initializeDOMElements();
            
            // Then initialize the application
            init();
        });
    </script>
</body>
</html>
